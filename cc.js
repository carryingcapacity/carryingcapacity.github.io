function filterFeatures(features,bounds){let filteredFeatures={roads:[],railways:[],buildings:[],waterBodies:[],benches:[],trees:[],smallMonuments:[],grass:[],bridges:[],barriers:[],boundaries:[],land:[],coastlines:[],parkingAreas:[],cityBlocks:[],plots:[],flowerbeds:[],privateAreas:[],walkableAreas:[]};for(const feature of features){if(!isAboveGround(feature))continue;if(isBuilding(feature))filteredFeatures.buildings.push(feature);if(isWater(feature))filteredFeatures.waterBodies.push(feature);if(isRoad(feature))filteredFeatures.roads.push(feature);if(isParkingArea(feature))filteredFeatures.parkingAreas.push(feature);if(isRailway(feature))filteredFeatures.railways.push(feature);if(isBridge(feature))filteredFeatures.bridges.push(feature);if(isPrivateArea(feature))filteredFeatures.privateAreas.push(feature);if(isBench(feature))filteredFeatures.benches.push(feature);if(isTree(feature))filteredFeatures.trees.push(feature);if(isSmallMonument(feature))filteredFeatures.smallMonuments.push(feature);if(isGrass(feature))filteredFeatures.grass.push(feature);if(isBarrier(feature))filteredFeatures.barriers.push(feature);if(isBoundary(feature))filteredFeatures.boundaries.push(feature);if(isLand(feature))filteredFeatures.land.push(feature);if(isCoastline(feature))filteredFeatures.coastlines.push(feature);if(isCityBlock(feature))filteredFeatures.cityBlocks.push(feature);if(isFlowerbed(feature))filteredFeatures.flowerbeds.push(feature);if(isWalkableArea(feature))filteredFeatures.walkableAreas.push(feature)}return filteredFeatures}function isRoad(feature){return feature.properties.highway&&feature.properties.highway!="pedestrian"&&feature.properties.foot!="designated"&&!feature.properties.footway&&feature.properties.highway!="footway"&&feature.properties.highway!="steps"&&feature.properties.highway!="cycleway"&&feature.properties.highway!="path"&&feature.properties.highway!="living_street"&&isAboveGround(feature)&&isLine(feature)}function isRailway(feature){return feature.properties.railway&&feature.properties.railway!="razed"&&feature.properties.railway!="abandoned"&&isAboveGround(feature)&&isLine(feature)}function isParkingArea(feature){return(feature.properties.amenity=="motorcycle_parking"||feature.properties.amenity=="bicycle_parking"||feature.properties.amenity=="parking")&&feature.properties.parking!=="underground"&&isPolygon(feature)}function isBuilding(feature){return feature.properties.building&&isAboveGround(feature)&&isPolygon(feature)}function isWalkableArea(feature){return(feature.properties.highway=="pedestrian"||feature.properties.foot=="designated"||feature.properties.footway)&&isPolygon(feature)}function isWater(feature){return(feature.properties.natural=="water"||feature.properties.place=="sea"||feature.properties.natural=="bay"||feature.properties.natural=="strait"||feature.properties.natural=="wetlands"||feature.properties.natural=="mud"||feature.properties.natural=="shoal"||feature.properties.leisure=="swimming_pool"||feature.properties.waterway)&&isPolygon(feature)}function isBridge(feature){return feature.properties.man_made=="bridge"&&isPolygon(feature)}function isTree(feature){return(feature.properties.natural=="tree"||feature.properties.natural=="tree_row")&&isPoint(feature)}function isBench(feature){return feature.properties.amenity=="bench"&&isPoint(feature)}function isSmallMonument(feature){return feature.properties.artwork_type||feature.properties.tourism=="artwork"||feature.properties.historic=="monument"||feature.properties.historic=="memorial"}function isGrass(feature){return feature.properties.landuse=="grass"&&isPolygon(feature)}function isFlowerbed(feature){return feature.properties.landuse=="flowerbed"&&isPolygon(feature)}function isPrivateArea(feature){return(feature.properties.landuse=="military"||feature.properties.landuse=="railway"||feature.properties.landuse=="construction"||feature.properties.landuse=="quarry"||feature.properties.aeroway||feature.properties.access=="private"||feature.properties.access=="no"||feature.properties.leisure=="stadium"||feature.properties.leisure=="golf_course"||feature.properties.sport||feature.properties.amenity=="school"||feature.properties.amenity=="prison"||feature.properties.barrier||isPlot(feature))&&isAboveGround(feature)&&isPolygon(feature)}function isCityBlock(feature){return feature.properties.place=="city_block"&&isPolygon(feature)}function isPlot(feature){return feature.properties.place=="plot"&&isPolygon(feature)}function isBarrier(feature){return feature.properties.barrier&&feature.properties.barrier!="kerb"&&!isPolygon(feature)}function isBoundary(feature){return feature.properties.boundary&&feature.properties.boundary=="administrative"&&isPolygon(feature)}function isAboveGround(feature){if(feature.properties.layer)return parseInt(feature.properties.layer)>-1;return true}function isLand(feature){return feature.properties.place||feature.properties.landuse||feature.properties.natural&&!isWater(feature)}function isCoastline(feature){return feature.properties.natural&&feature.properties.natural==="coastline"}function isLine(feature){return feature.geometry.type=="LineString"}function isPolygon(feature){return feature.geometry.type.includes("Polygon")}function isPoint(feature){return feature.geometry.type=="Point"}function processSmallMonuments(features){let processed=[];for(const f of features){if(isPolygon(f))processed.push(addBuffer(f,.01));else processed.push(addBuffer(f,1))}return processed}function processBuildings(features,removeInnerRings=true){let processed=[];for(const f of features){if(removeInnerRings&&f.geometry.type=="Polygon"){let outerRing=f.geometry.coordinates[0];f.geometry.coordinates=[outerRing]}processed.push(addBuffer(f,.05))}return processed}function processBenches(features){let processed=[];for(const f of features){processed.push(turf.buffer(f,.5,{units:"meters",steps:4}))}return processed}function processTrees(features){let processed=[];for(const f of features){processed.push(addBuffer(f,.5))}return processed}function processBarriers(features){let processed=[];for(const f of features){processed.push(addBuffer(f,.4))}return processed}function processWater(filteredFeatures,bounds){let bridges=addBufferMany(filteredFeatures.bridges,.01);let waterBodies=addBufferMany(filteredFeatures.waterBodies,.05);let processed=[];for(let water of waterBodies){processed.push(differenceMany(water,bridges))}return processed}function processRoads(roads,laneWidth,diagonalWidth,parallelWidth){let processed=[];for(let road of roads){let numLanes=parseInt(road.properties["lanes"]?road.properties["lanes"]:1);let numBusLanes=parseInt(road.properties["lanes:bus"]?road.properties["lanes:bus"]:0);let estWidth=(numLanes+numBusLanes)*laneWidth;if(road.properties["parking:lane:left"])if(road.properties["parking:lane:left"]=="parallel")estWidth+=parallelWidth;else if(road.properties["parking:lane:left"]!="no_parking")estWidth+=diagonalWidth;if(road.properties["parking:lane:right"])if(road.properties["parking:lane:right"]=="parallel")estWidth+=parallelWidth;else if(road.properties["parking:lane:right"]!="no_parking")estWidth+=diagonalWidth;if(road.properties["parking:lane:both"])if(road.properties["parking:lane:both"]=="parallel")estWidth+=parallelWidth*2;else if(road.properties["parking:lane:both"]!="no_parking")estWidth+=diagonalWidth*2;road.properties["estWidth"]=estWidth;processed.push(turf.buffer(road,estWidth/2,{units:"meters"}))}return processed}function addBuffer(feature,value){try{let buff=turf.buffer(feature,value,{units:"meters"});if(buff){buff=truncateGeoJSON(buff)}return buff}catch(error){console.log(feature);console.log(error)}}function addBufferMany(features,value){let buffered=[];for(let feature of features){let buff=addBuffer(feature,value);if(buff)buffered.push(addBuffer(feature,value))}return buffered}function truncateGeoJSON(geojson,decimals=7){const factor=Math.pow(10,decimals);const trunc=num=>Math.trunc(num*factor)/factor;const truncateCoord=coord=>coord.map(trunc);const truncateCoords=coords=>{if(typeof coords[0]==="number"){return truncateCoord(coords)}return coords.map(truncateCoords)};const processGeometry=geometry=>{if(!geometry)return geometry;switch(geometry.type){case"Point":case"MultiPoint":case"LineString":case"MultiLineString":case"Polygon":case"MultiPolygon":return{...geometry,coordinates:truncateCoords(geometry.coordinates)};case"GeometryCollection":return{...geometry,geometries:geometry.geometries.map(processGeometry)};default:return geometry}};if(geojson.type==="FeatureCollection"){return{...geojson,features:geojson.features.map(f=>({...f,geometry:processGeometry(f.geometry)}))}}if(geojson.type==="Feature"){return{...geojson,geometry:processGeometry(geojson.geometry)}}return processGeometry(geojson)}function differenceMany(feature,features){let diff=feature;for(let f of features){diff=turf.difference(diff,f)}return diff}function unionMany(feature,features){let union=feature;for(let f of features){union=turf.union(union,f)}return union}function unionArray(features){let union=features.shift();for(let f of features){union=turf.union(union,f)}return union}function divideArea(bounds,numAreas,horizontal=true){let bbox=turf.bbox(bounds);let minX=bbox[0];let minY=bbox[1];let maxX=bbox[2];let maxY=bbox[3];let deltaX=(maxX-minX)/numAreas;let deltaY=(maxY-minY)/numAreas;let subAreas=[];for(let i=0;i<numAreas;i++){let points;if(horizontal){points=[[[minX+i*deltaX,maxY],[minX+(i+1)*deltaX,maxY],[minX+(i+1)*deltaX,minY],[minX+i*deltaX,minY],[minX+i*deltaX,maxY]]]}else{points=[[[minX,maxY-i*deltaY],[maxX,maxY-i*deltaY],[maxX,maxY-(i+1)*deltaY],[minX,maxY-(i+1)*deltaY],[minX,maxY-i*deltaY]]]}let subArea=addBuffer(turf.polygon(points),.01);let subAreaIntersect=turf.intersect(subArea,bounds);if(subAreaIntersect)subAreas.push(subAreaIntersect)}return subAreas}function walkableArea(features,bounds,options={}){let LANE_WIDTH=3;let RAIL_WIDTH=3;let PARALLEL_PARKING_WIDTH=1.8;let DIAGONAL_PARKING_WIDTH=5;let REMOVE_BUILDING_INNER_RINGS=true;let WALKABLE_ROADS=false;let UNWALKABLE_GRASS=false;let WALKABLE_PARKING_AREAS=false;let WALKABLE_CITY_BLOCKS=false;let WALKABLE_PRIVATE_AREAS=false;if(options.laneWidth)LANE_WIDTH=options.laneWidth;if(options.railWidth)RAIL_WIDTH=options.railWidth;if(options.parallelWidth)PARALLEL_PARKING_WIDTH=options.parallelWidth;if(options.diagonalWidth)DIAGONAL_PARKING_WIDTH=options.diagonalWidth;if(options.flattenBuildings)REMOVE_BUILDING_INNER_RINGS=options.flattenBuildings;if(options.walkableRoads)WALKABLE_ROADS=options.walkableRoads;if(options.unwalkableGrass)UNWALKABLE_GRASS=options.unwalkableGrass;if(options.walkableParkingAreas)WALKABLE_PARKING_AREAS=options.walkableParkingAreas;if(options.walkablePrivateAreas)WALKABLE_PRIVATE_AREAS=options.walkablePrivateAreas;if(options.walkableCityBlocks)WALKABLE_CITY_BLOCKS=options.walkableCityBlocks;let filteredFeatures=filterFeatures(features,bounds);let roads=filteredFeatures.roads;let railways=filteredFeatures.railways;let buildings=filteredFeatures.buildings;let waterBodies=filteredFeatures.waterBodies;let grass=filteredFeatures.grass;let benches=filteredFeatures.benches;let trees=filteredFeatures.trees;let smallMonuments=filteredFeatures.smallMonuments;let barriers=filteredFeatures.barriers;let land=filteredFeatures.land;let coastlines=filteredFeatures.coastlines;let boundaries=filteredFeatures.boundaries;let parkingAreas=filteredFeatures.parkingAreas;let flowerbeds=filteredFeatures.flowerbeds;let privateAreas=filteredFeatures.privateAreas;let cityBlocks=filteredFeatures.cityBlocks;if(WALKABLE_ROADS){roads=[]}else{roads=processRoads(roads,LANE_WIDTH,DIAGONAL_PARKING_WIDTH,PARALLEL_PARKING_WIDTH)}buildings=processBuildings(buildings,REMOVE_BUILDING_INNER_RINGS);railways=addBufferMany(railways,RAIL_WIDTH/2);waterBodies=processWater(filteredFeatures,bounds);benches=processBenches(benches);trees=processTrees(trees);smallMonuments=processSmallMonuments(smallMonuments);barriers=processBarriers(barriers);parkingAreas=addBufferMany(parkingAreas,.05);const isNotLand=land.length==0&&buildings.length==0&&roads.length==0;if(boundaries.length==0){if(isNotLand){return addBuffer(turf.centroid(bounds),.01)}}else if(coastlines.length>0){let unmappedWater=turf.difference(bounds,boundaries[0]);waterBodies.push(unmappedWater)}let unwalkablePolygons=buildings.concat(waterBodies,roads,railways,benches,trees,smallMonuments,barriers,flowerbeds);if(UNWALKABLE_GRASS)unwalkablePolygons=unwalkablePolygons.concat(grass);if(!WALKABLE_PARKING_AREAS)unwalkablePolygons=unwalkablePolygons.concat(parkingAreas);if(!WALKABLE_PRIVATE_AREAS)unwalkablePolygons=unwalkablePolygons.concat(privateAreas);if(!WALKABLE_CITY_BLOCKS)unwalkablePolygons=unwalkablePolygons.concat(cityBlocks);if(options.customFeatures){unwalkablePolygons=unwalkablePolygons.concat(options.customFeatures.features)}let walkableAreaPolygon=truncateGeoJSON(bounds,7);for(const f of unwalkablePolygons){try{let diff=turf.difference(walkableAreaPolygon,f);if(diff===null){diff=addBuffer(turf.centroid(bounds),.01);if(walkableAreaPolygon.properties){diff.properties=walkableAreaPolygon.properties}return diff}walkableAreaPolygon=diff}catch(error){if(f&&f.properties){console.log("Error with feature: "+f.properties);console.log(f);console.log(error)}}}return truncateGeoJSON(walkableAreaPolygon)}function walkableAreaWithSubAreas(features,bounds,options,workerId){bounds_area=turf.area(bounds);numDivisions=Math.ceil(bounds_area/1e5);numDivisions=numDivisions>=1?numDivisions:1;console.log("Number of area divisions: "+numDivisions);let subAreas=divideArea(bounds,numDivisions,horizontal=false);let subAreaFeatures=[];let totalPolygons=0;let unwalkablePolygons=[];for(let subArea of subAreas){let subFeatures=[];for(let feature of features){if(subArea&&turf.booleanIntersects(feature,subArea)){subFeatures.push(feature)}}subAreaFeatures.push(subFeatures)}progress={totalPolygons:totalPolygons,processedPolygons:0};for(let i=0;i<subAreas.length;i++){unwalkablePolygons.push(walkableArea(subAreaFeatures[i],subAreas[i],options));if(workerId!==undefined&&workerId!==null){postMessage({progress:true,processedPolygons:i+1,totalPolygons:subAreas.length,workerId:workerId})}}results=[];try{results=unionArray(unwalkablePolygons)}catch(e){console.log("Error on union... trying again");console.log(e);unwalkablePolygons=addBufferMany(unwalkablePolygons,.1);try{results=unionArray(unwalkablePolygons)}catch(e1){console.log(e1)}}return results}